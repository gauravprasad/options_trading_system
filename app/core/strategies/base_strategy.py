from abc import ABC, abstractmethod
from typing import List, Dict, Optional, Tuple
from datetime import datetime, timedelta
import pandas as pd
from dataclasses import dataclass
from decimal import Decimal

from app.utils.logger import trading_logger
from app.models.database_models import StrategyType, OptionType, OptionAction

@dataclass
class StrategySignal:
    """Signal generated by a trading strategy."""
    action: str  # 'OPEN', 'CLOSE', 'HOLD'
    confidence: float  # 0.0 to 1.0
    reasoning: str
    legs: List[Dict]  # List of option legs to execute
    max_risk: float
    max_profit: float
    break_even_points: List[float]
    target_exit_criteria: Dict
    stop_loss_criteria: Dict
    expected_profit_probability: float

@dataclass
class MarketConditions:
    """Current market conditions for strategy evaluation."""
    underlying_price: float
    implied_volatility: float
    historical_volatility: float
    volume: int
    sentiment_score: float
    technical_indicators: Dict
    options_chain: List[Dict]
    days_to_earnings: Optional[int] = None
    dividend_yield: Optional[float] = None

class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    Defines the interface that all strategies must implement.
    """

    def __init__(self, symbol: str, parameters: Dict = None):
        self.symbol = symbol
        self.parameters = parameters or {}
        self.strategy_type = self._get_strategy_type()
        self.logger = trading_logger.bind(strategy=self.strategy_type.value, symbol=symbol)

        # Default parameters that can be overridden
        self.default_params = {
            'max_position_size': 0.05,  # 5% of portfolio
            'min_profit_target': 0.20,  # 20% profit target
            'max_loss_limit': 0.50,     # 50% loss limit
            'min_dte': 7,               # Minimum days to expiration
            'max_dte': 45,              # Maximum days to expiration
            'min_volume': 100,          # Minimum option volume
            'min_open_interest': 500,   # Minimum open interest
            'commission_per_contract': 0.65,  # Commission cost
        }

        # Merge with provided parameters
        self.params = {**self.default_params, **self.parameters}

    @abstractmethod
    def _get_strategy_type(self) -> StrategyType:
        """Return the strategy type enum."""
        pass

    @abstractmethod
    def evaluate_entry_conditions(self, market_conditions: MarketConditions) -> StrategySignal:
        """
        Evaluate whether to enter a position based on current market conditions.

        Args:
            market_conditions: Current market state

        Returns:
            StrategySignal with action and details
        """
        pass

    @abstractmethod
    def evaluate_exit_conditions(self, current_position: Dict,
                                 market_conditions: MarketConditions) -> StrategySignal:
        """
        Evaluate whether to exit an existing position.

        Args:
            current_position: Current position details
            market_conditions: Current market state

        Returns:
            StrategySignal with action and details
        """
        pass

    @abstractmethod
    def calculate_position_size(self, portfolio_value: float,
                                max_risk: float) -> int:
        """
        Calculate the appropriate position size based on risk management.

        Args:
            portfolio_value: Current portfolio value
            max_risk: Maximum risk amount

        Returns:
            Number of contracts to trade
        """
        pass

    def filter_options_chain(self, options_chain: List[Dict],
                             option_type: str = None,
                             min_dte: int = None,
                             max_dte: int = None) -> List[Dict]:
        """
        Filter options chain based on strategy criteria.

        Args:
            options_chain: List of option contracts
            option_type: 'call' or 'put' or None for both
            min_dte: Minimum days to expiration
            max_dte: Maximum days to expiration

        Returns:
            Filtered options list
        """
        if not options_chain:
            return []

        filtered = options_chain.copy()

        # Filter by option type
        if option_type:
            filtered = [opt for opt in filtered if opt.get('type', '').lower() == option_type.lower()]

        # Filter by days to expiration
        current_date = datetime.now().date()
        min_dte = min_dte or self.params['min_dte']
        max_dte = max_dte or self.params['max_dte']

        filtered_by_dte = []
        for opt in filtered:
            if 'expiration_date' in opt:
                expiry = datetime.strptime(opt['expiration_date'], '%Y-%m-%d').date()
                dte = (expiry - current_date).days
                if min_dte <= dte <= max_dte:
                    opt['days_to_expiration'] = dte
                    filtered_by_dte.append(opt)

        # Filter by volume and open interest (if data available)
        final_filtered = []
        for opt in filtered_by_dte:
            volume = opt.get('volume', 0)
            open_interest = opt.get('open_interest', 0)

            if (volume >= self.params['min_volume'] and
                    open_interest >= self.params['min_open_interest']):
                final_filtered.append(opt)

        return final_filtered

    def calculate_profit_loss(self, legs: List[Dict],
                              underlying_prices: List[float]) -> Dict:
        """
        Calculate profit/loss for a multi-leg position at different underlying prices.

        Args:
            legs: List of option legs with details
            underlying_prices: List of underlying prices to evaluate

        Returns:
            Dictionary with P&L analysis
        """
        results = {}

        for price in underlying_prices:
            total_pnl = 0

            for leg in legs:
                # Simplified P&L calculation (ignores time decay, volatility changes)
                strike = leg['strike_price']
                action = leg['action']  # 'BUY' or 'SELL'
                option_type = leg['option_type']  # 'CALL' or 'PUT'
                quantity = leg['quantity']
                entry_price = leg.get('entry_price', 0)

                # Calculate intrinsic value
                if option_type.upper() == 'CALL':
                    intrinsic_value = max(0, price - strike)
                else:  # PUT
                    intrinsic_value = max(0, strike - price)

                # Calculate P&L for this leg
                if action.upper() == 'BUY':
                    leg_pnl = (intrinsic_value - entry_price) * quantity
                else:  # SELL
                    leg_pnl = (entry_price - intrinsic_value) * quantity

                total_pnl += leg_pnl

            results[price] = total_pnl

        return results

    def find_break_even_points(self, legs: List[Dict],
                               price_range: Tuple[float, float] = None) -> List[float]:
        """
        Find break-even points for the strategy.

        Args:
            legs: List of option legs
            price_range: (min_price, max_price) to search

        Returns:
            List of break-even prices
        """
        if not price_range:
            # Determine price range based on strike prices
            strikes = [leg['strike_price'] for leg in legs]
            min_strike = min(strikes)
            max_strike = max(strikes)
            price_range = (min_strike * 0.8, max_strike * 1.2)

        break_even_points = []
        step_size = (price_range[1] - price_range[0]) / 1000

        prev_pnl = None
        for i in range(1001):
            price = price_range[0] + i * step_size
            pnl_dict = self.calculate_profit_loss(legs, [price])
            current_pnl = pnl_dict[price]

            # Check for sign change (break-even point)
            if prev_pnl is not None:
                if (prev_pnl < 0 < current_pnl) or (prev_pnl > 0 > current_pnl):
                    # Interpolate to find more precise break-even
                    be_price = price - step_size * (current_pnl / (current_pnl - prev_pnl))
                    break_even_points.append(round(be_price, 2))

            prev_pnl = current_pnl

        return break_even_points

    def calculate_max_profit_loss(self, legs: List[Dict]) -> Tuple[float, float]:
        """
        Calculate maximum profit and loss for the strategy.

        Args:
            legs: List of option legs

        Returns:
            Tuple of (max_profit, max_loss)
        """
        # Determine price range for analysis
        strikes = [leg['strike_price'] for leg in legs]
        min_price = min(strikes) * 0.5
        max_price = max(strikes) * 1.5

        # Calculate P&L across price range
        price_range = [min_price + i * (max_price - min_price) / 100 for i in range(101)]
        pnl_dict = self.calculate_profit_loss(legs, price_range)

        pnl_values = list(pnl_dict.values())
        max_profit = max(pnl_values)
        max_loss = min(pnl_values)

        return max_profit, max_loss

    def validate_strategy_rules(self, signal: StrategySignal,
                                market_conditions: MarketConditions) -> bool:
        """
        Validate that the strategy signal follows risk management rules.

        Args:
            signal: Strategy signal to validate
            market_conditions: Current market conditions

        Returns:
            True if signal is valid, False otherwise
        """
        # Check confidence threshold
        if signal.confidence < 0.6:  # Minimum 60% confidence
            self.logger.warning("Signal rejected: Low confidence",
                                confidence=signal.confidence)
            return False

        # Check risk/reward ratio
        if signal.max_risk > 0:
            risk_reward_ratio = signal.max_profit / signal.max_risk
            if risk_reward_ratio < 1.5:  # Minimum 1.5:1 risk/reward
                self.logger.warning("Signal rejected: Poor risk/reward ratio",
                                    ratio=risk_reward_ratio)
                return False

        # Check days to expiration
        for leg in signal.legs:
            expiry_date = datetime.strptime(leg['expiry_date'], '%Y-%m-%d').date()
            dte = (expiry_date - datetime.now().date()).days
            if dte < self.params['min_dte'] or dte > self.params['max_dte']:
                self.logger.warning("Signal rejected: DTE out of range",
                                    dte=dte)
                return False

        # Check implied volatility (if available)
        if hasattr(market_conditions, 'implied_volatility'):
            if market_conditions.implied_volatility < 0.1:  # Less than 10% IV
                self.logger.warning("Signal rejected: Very low implied volatility")
                return False

        return True

    def adjust_for_market_conditions(self, signal: StrategySignal,
                                     market_conditions: MarketConditions) -> StrategySignal:
        """
        Adjust strategy signal based on current market conditions.

        Args:
            signal: Original strategy signal
            market_conditions: Current market conditions

        Returns:
            Adjusted strategy signal
        """
        adjusted_signal = signal

        # Adjust position size based on volatility
        if market_conditions.implied_volatility > 0.3:  # High volatility
            # Reduce position size in high volatility environments
            for leg in adjusted_signal.legs:
                leg['quantity'] = int(leg['quantity'] * 0.75)
            adjusted_signal.reasoning += " [Reduced size due to high volatility]"

        # Adjust profit targets based on market sentiment
        if market_conditions.sentiment_score < -0.5:  # Very bearish sentiment
            # Tighten profit targets in bearish markets
            adjusted_signal.target_exit_criteria['profit_target'] *= 0.8
            adjusted_signal.reasoning += " [Tightened targets due to bearish sentiment]"

        return adjusted_signal

    def generate_trade_summary(self, signal: StrategySignal) -> str:
        """Generate a human-readable summary of the trade."""
        summary = f"{self.strategy_type.value} on {self.symbol}\n"
        summary += f"Action: {signal.action}\n"
        summary += f"Confidence: {signal.confidence:.1%}\n"
        summary += f"Max Risk: ${signal.max_risk:,.2f}\n"
        summary += f"Max Profit: ${signal.max_profit:,.2f}\n"
        summary += f"Break-even: {signal.break_even_points}\n"
        summary += f"Reasoning: {signal.reasoning}\n"

        summary += "\nLegs:\n"
        for i, leg in enumerate(signal.legs, 1):
            summary += f"  {i}. {leg['action']} {leg['quantity']} "
            summary += f"{leg['option_type']} ${leg['strike_price']} "
            summary += f"exp {leg['expiry_date']}\n"

        return summary